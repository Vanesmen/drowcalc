/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./drowCalc_dev.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/cleanCanvas.js":
/*!****************************!*\
  !*** ./app/cleanCanvas.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// очистка холста\r\nlet cleanCanvas = (id) => {\r\n    let drowPlan = document.getElementById(id);\r\n    let ctx = drowPlan.getContext(\"2d\");\r\n    let currentClientWidth = drowPlan.clientWidth;\r\n    let currentClientHeight = drowPlan.clientHeight;\r\n    ctx.clearRect(0, 0, currentClientWidth, currentClientHeight);\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (cleanCanvas);\n\n//# sourceURL=webpack:///./app/cleanCanvas.js?");

/***/ }),

/***/ "./app/createInst.js":
/*!***************************!*\
  !*** ./app/createInst.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet defaultPaddingT = 60;\r\nlet defaultPaddingL = 60;\r\n\r\nfunction Inst(id) {\r\n    this.id = id;\r\n    this.widthRoom = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#widthRoom\").value;\r\n    this.heightRoom = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#heightRoom\").value;\r\n\r\n    this.defaultPaddingT = 60; //Стандартный оступ основного рисунка от стенок canvas\r\n    this.defaultPaddingL = 60; //Стандартный оступ основного рисунка от стенок canvas\r\n\r\n    this.paddingT = defaultPaddingT; //Оступ основного рисунка от стенок canvas\r\n    this.paddingL = defaultPaddingL; //Оступ основного рисунка от стенок canvas\r\n\r\n    this.dash = true;\r\n    this.dashL = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#dashL\").value; //Отступ от стенок комнаты\r\n    this.dashR = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#dashR\").value; //Отступ от стенок комнаты\r\n    this.dashT = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#dashT\").value; //Отступ от стенок комнаты\r\n    this.dashB = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#dashB\").value; //Отступ от стенок комнаты\r\n    // Мебель в комнате\r\n    this.tl_w = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#tl_w\").value; // Позиция 1 // Позиция 1\r\n    this.tl_h = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#tl_h\").value;\r\n\r\n    this.ml_w = 0; // Позиция 4\r\n    this.ml_h = 0;\r\n\r\n    this.bl_w = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#bl_w\").value; // Позиция 7 // Позиция 3\r\n    this.bl_h = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#bl_h\").value;\r\n\r\n    this.tm_w = 0; // Позиция 2\r\n    this.tm_h = 0;\r\n\r\n    this.mm_w = 0; // Позиция 5\r\n    this.mm_h = 0;\r\n\r\n    this.bm_w = 0; // Позиция 8\r\n    this.bm_h = 0;\r\n\r\n    this.rt_w = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#rt_w\").value; // Позиция 3 // Позиция 2\r\n    this.rt_h = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#rt_h\").value;\r\n\r\n    this.rm_w = 0; // Позиция 6\r\n    this.rm_h = 0;\r\n\r\n    this.rb_w = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#rb_w\").value; // Позиция 9 // Позиция 4\r\n    this.rb_h = document.querySelectorAll(\"[fid]\")[id.slice(-1) - 2].querySelector(\"#rb_h\").value;\r\n\r\n    this.straightLineDirection = true; //straightLineDirection, true - внизу/справа\r\n\r\n    this.widthTurnReal = 250; //в мм\r\n    this.lengthSystem = 700; // Длинна системы. По умолчанию минимальная 7м. Варианты: 7м, 14м, 21м, 28м, 35м, 42м, 56м, 70м, 84м  \r\n    this.sistemLen = 7500;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (Inst);\n\n//# sourceURL=webpack:///./app/createInst.js?");

/***/ }),

/***/ "./app/drowCalc_init.js":
/*!******************************!*\
  !*** ./app/drowCalc_init.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _searchAllCanvasBlock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchAllCanvasBlock */ \"./app/searchAllCanvasBlock.js\");\n/* harmony import */ var _createInst__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createInst */ \"./app/createInst.js\");\n/* harmony import */ var _cleanCanvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cleanCanvas */ \"./app/cleanCanvas.js\");\n/* harmony import */ var _drowDashLinemainBorder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./drowDashLinemainBorder */ \"./app/drowDashLinemainBorder.js\");\n/* harmony import */ var _sizeLines__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sizeLines */ \"./app/sizeLines.js\");\n\r\n\r\n\r\n\r\n\r\n// import createEventInputs from \"./createEventInputs\"\r\n// import canvasStartDrow from \"./canvasStartDrow\";\r\n\r\nlet myInitCode = () => {\r\n\r\n    let goSVG = [];\r\n\r\n    // Формы комнат\r\n\r\n    let canvasStartDrow = (inst) => {\r\n        createEventInputs(inst);\r\n        drowRectangle(inst);\r\n    }\r\n\r\n    let drowRectangle = (inst) => {\r\n        Object(_cleanCanvas__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(inst.id);\r\n        let drowPlan = document.getElementById(inst.id);\r\n        let ctx = drowPlan.getContext(\"2d\");\r\n\r\n\r\n        let currentClientWidth = drowPlan.clientWidth;\r\n        let currentClientHeight = drowPlan.clientHeight;\r\n\r\n        if (inst.widthRoom && inst.heightRoom) {\r\n            inst.paddingT = inst.defaultPaddingT + (1 - inst.heightRoom / inst.widthRoom) * (currentClientHeight - inst.defaultPaddingT * 2) * 0.5;\r\n\r\n            // Отрисовка пунктирной границы только когда задана ширина и высота\r\n            let dasL = (inst.dashL * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom + inst.paddingL;\r\n            let dasR = (inst.dashR * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom + inst.paddingL;\r\n            let dasT = (inst.dashT * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom + inst.paddingT;\r\n            let dasB = (inst.dashB * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom + inst.paddingT;\r\n\r\n            Object(_drowDashLinemainBorder__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(inst.id, dasL, dasT, dasR, dasB, currentClientWidth, currentClientHeight);\r\n\r\n            Object(_sizeLines__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(inst);\r\n            drowRedLine(inst, dasL, dasR, dasT, dasB);\r\n        }\r\n\r\n        if (inst.dash == true) {\r\n            insideBorder(inst);\r\n\r\n\r\n\r\n\r\n            // Обновление полей ввода ???\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#widthRoom\").value = inst.widthRoom;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#heightRoom\").value = inst.heightRoom;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashL\").value = inst.dashL;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashR\").value = inst.dashR;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashT\").value = inst.dashT;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashB\").value = inst.dashB;\r\n\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_w\").value = inst.tl_w;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_h\").value = inst.tl_h;\r\n\r\n            // document.getElementById(\"ml_w\").value = inst.ml_w;\r\n            // document.getElementById(\"ml_h\").value = inst.ml_h;\r\n\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_w\").value = inst.bl_w;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_h\").value = inst.bl_h;\r\n\r\n            // document.getElementById(\"tm_w\").value = inst.tm_w;\r\n            // document.getElementById(\"tm_h\").value = inst.tm_h;\r\n\r\n            // document.getElementById(\"mm_w\").value = inst.mm_w;\r\n            // document.getElementById(\"mm_h\").value = inst.mm_h;\r\n\r\n            // document.getElementById(\"bm_w\").value = inst.bm_w;\r\n            // document.getElementById(\"bm_h\").value = inst.bm_h;\r\n\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_w\").value = inst.rt_w;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_h\").value = inst.rt_h;\r\n\r\n            // document.getElementById(\"rm_w\").value = inst.rm_w;\r\n            // document.getElementById(\"rm_h\").value = inst.rm_h;\r\n\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_w\").value = inst.rb_w;\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_h\").value = inst.rb_h;\r\n\r\n        }\r\n\r\n        let drow = (ctx, clientWidth, clientHeight, paddingL, paddingT) => {\r\n            ctx.strokeRect(paddingL, paddingT, clientWidth - 2 * paddingL, clientHeight - 2 * paddingT);\r\n        }\r\n\r\n\r\n        drow(ctx, currentClientWidth, currentClientHeight, inst.paddingL, inst.paddingT);\r\n\r\n    }\r\n\r\n\r\n    //События к инпутам\r\n    let createEventInputs = (inst) => {\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#widthRoom\").addEventListener(\"change\", function (event) {\r\n            // Валидация \r\n            if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#widthRoom\").value < inst.heightRoom) {\r\n                inst.widthRoom = inst.heightRoom;\r\n                alert(\"Стороны B и D, должны быть меньше или равны сторонам A, C\");\r\n            } else {\r\n                inst.widthRoom = document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#widthRoom\").value;\r\n            }\r\n            drowRectangle(inst);\r\n        })\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#heightRoom\").addEventListener(\"change\", function (event) {\r\n            // Валидация\r\n            if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#heightRoom\").value > inst.widthRoom) {\r\n                inst.heightRoom = inst.widthRoom;\r\n                alert(\"Стороны A и C, должны быть меньше или равны сторонам B, D\");\r\n            } else {\r\n                inst.heightRoom = document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#heightRoom\").value;\r\n            }\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashL\").addEventListener(\"change\", function (event) {\r\n            inst.dashL = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashL\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashR\").addEventListener(\"change\", function (event) {\r\n            inst.dashR = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashR\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashT\").addEventListener(\"change\", function (event) {\r\n            inst.dashT = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashT\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashB\").addEventListener(\"change\", function (event) {\r\n            inst.dashB = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#dashB\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_w\").addEventListener(\"change\", function (event) {\r\n            inst.tl_w = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_w\").value);\r\n            drowRectangle(inst);\r\n        })\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_h\").addEventListener(\"change\", function (event) {\r\n            inst.tl_h = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#tl_h\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        // document.getElementById(\"ml_w\").addEventListener(\"change\", function (event) {\r\n        //     inst.ml_w = Number(document.getElementById(\"ml_w\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n        // document.getElementById(\"ml_h\").addEventListener(\"change\", function (event) {\r\n        //     inst.ml_h = Number(document.getElementById(\"ml_h\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_w\").addEventListener(\"change\", function (event) {\r\n            inst.bl_w = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_w\").value);\r\n            drowRectangle(inst);\r\n        })\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_h\").addEventListener(\"change\", function (event) {\r\n            inst.bl_h = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#bl_h\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        // document.getElementById(\"tm_w\").addEventListener(\"change\", function (event) {\r\n        //     inst.tm_w = Number(document.getElementById(\"tm_w\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n        // document.getElementById(\"tm_h\").addEventListener(\"change\", function (event) {\r\n        //     inst.tm_h = Number(document.getElementById(\"tm_h\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n\r\n        // document.getElementById(\"mm_w\").addEventListener(\"change\", function (event) {\r\n        //     inst.mm_w = Number(document.getElementById(\"mm_w\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n        // document.getElementById(\"mm_h\").addEventListener(\"change\", function (event) {\r\n        //     inst.mm_h = Number(document.getElementById(\"mm_h\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n\r\n        // document.getElementById(\"bm_w\").addEventListener(\"change\", function (event) {\r\n        //     inst.bm_w = Number(document.getElementById(\"bm_w\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n        // document.getElementById(\"bm_h\").addEventListener(\"change\", function (event) {\r\n        //     inst.bm_h = Number(document.getElementById(\"bm_h\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_w\").addEventListener(\"change\", function (event) {\r\n            inst.rt_w = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_w\").value);\r\n            drowRectangle(inst);\r\n        })\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_h\").addEventListener(\"change\", function (event) {\r\n            inst.rt_h = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rt_h\").value);\r\n            drowRectangle(inst);\r\n        })\r\n\r\n        // document.getElementById(\"rm_w\").addEventListener(\"change\", function (event) {\r\n        //     inst.rm_w = Number(document.getElementById(\"rm_w\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n        // document.getElementById(\"rm_h\").addEventListener(\"change\", function (event) {\r\n        //     inst.rm_h = Number(document.getElementById(\"rm_h\").value);\r\n        //     drowRectangle(inst);\r\n        // })\r\n\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_w\").addEventListener(\"change\", function (event) {\r\n            inst.rb_w = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_w\").value);\r\n            drowRectangle(inst);\r\n        })\r\n        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_h\").addEventListener(\"change\", function (event) {\r\n            inst.rb_h = Number(document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\"#rb_h\").value);\r\n            drowRectangle(inst);\r\n        })\r\n    };\r\n\r\n\r\n    let dispatchForm = (formID, canvasName) => {\r\n        switch (formID) {\r\n            case \"drowPlan\":\r\n                let instLoc = new _createInst__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvasName);\r\n                instLoc.dash = true;\r\n                drowRectangle(instLoc);\r\n                break;\r\n            case \"drowPlan2\":\r\n                drowRectangleRightCorner(canvasName);\r\n                break;\r\n            case \"drowPlan3\":\r\n                drowRectangleLeftCorner(canvasName);\r\n                break;\r\n            case \"drowPlan4\":\r\n                drowRectangleBottomRightCorner(canvasName);\r\n                break;\r\n            case \"drowPlan5\":\r\n                drowRectangleBottomLeftCorner(canvasName);\r\n                break;\r\n            case \"drowPlan6\":\r\n                drowRectangleBothCorner(canvasName);\r\n                break;\r\n            case \"drowPlan7\":\r\n                drowRectangleBothBeveledCorner(canvasName);\r\n                break;\r\n            case \"drowPlan8\":\r\n                drowRectangleBothBeveledBottomBothCorner(canvasName);\r\n                break;\r\n            case \"drowPlan9\":\r\n                drowRectangleLeftCornerBottomRightCorner(canvasName);\r\n                break;\r\n            case \"drowPlan10\":\r\n                drowRectangleRightCornerBottomLeftCorner(canvasName);\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    // Границы мебели в комнате\r\n\r\n    let insideBorder = (inst) => {\r\n\r\n        let drowPlan = document.getElementById(inst.id);\r\n        let ctx = drowPlan.getContext(\"2d\");\r\n\r\n        let currentClientWidth = drowPlan.clientWidth;\r\n        let currentClientHeight = drowPlan.clientHeight;\r\n\r\n\r\n        let tl = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect(inst.paddingL, inst.paddingT, xp, yp);\r\n            ctx.setLineDash([]);\r\n\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n\r\n            ctx.strokeText(\"1\", inst.paddingL + numX, inst.paddingT + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n\r\n        let ml = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect(inst.paddingL, (currentClientHeight / 2 - yp / 2), xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n            ctx.strokeText(\"4\", inst.paddingL + numX, (currentClientHeight / 2 - numY) + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n        let bl = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect(inst.paddingL, currentClientHeight - inst.paddingT - yp, xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n\r\n            ctx.strokeText(\"3\", inst.paddingL + numX, currentClientHeight - inst.paddingT - numY * 2 + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n\r\n\r\n\r\n        let tm = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth / 2 - xp / 2), inst.paddingT, xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n\r\n            ctx.strokeText(\"2\", (currentClientWidth / 2 - numX) + numX, inst.paddingT + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n        let mm = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth / 2 - xp / 2), (currentClientHeight / 2 - yp / 2), xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n            ctx.strokeText(\"5\", (currentClientWidth / 2 - numX) + numX, (currentClientHeight / 2 - numY) + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n        let bm = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth / 2 - xp / 2), currentClientHeight - inst.paddingT - yp, xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n            ctx.strokeText(\"8\", (currentClientWidth / 2 - numX) + numX, currentClientHeight - inst.paddingT - numY * 2 + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n\r\n\r\n\r\n        let rt = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth - inst.paddingL - xp), inst.paddingT, xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n            ctx.strokeText(\"2\", (currentClientWidth - inst.paddingL - numX * 2) + numX, inst.paddingT + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n        let rm = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth - inst.paddingL - xp), (currentClientHeight / 2 - yp / 2), xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n            ctx.strokeText(\"6\", (currentClientWidth - inst.paddingL - numX * 2) + numX, (currentClientHeight / 2 - numY) + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n        let rb = (x, y) => {\r\n\r\n            let xp = (x * (currentClientWidth - inst.defaultPaddingL * 2)) / inst.widthRoom;\r\n            let yp = (y * (currentClientWidth - inst.paddingT * 2)) / inst.heightRoom;\r\n\r\n            ctx.setLineDash([4, 6]);\r\n            ctx.strokeRect((currentClientWidth - inst.paddingL - xp), currentClientHeight - inst.paddingT - yp, xp, yp);\r\n            ctx.setLineDash([]);\r\n            // цифра в центре\r\n            ctx.font = 'bold 30px sans-serif';\r\n            ctx.textBaseline = \"bottom\";\r\n            ctx.strokeStyle = \"#F00\";\r\n            ctx.textBaseline = \"middle\";\r\n            ctx.textAlign = \"center\";\r\n\r\n            let numX = xp / 2;\r\n            if (xp / 2 < 50) {\r\n                numX = 50;\r\n            }\r\n\r\n            let numY = yp / 2;\r\n            if (yp / 2 < 50) {\r\n                numY = 50;\r\n            }\r\n\r\n            ctx.strokeText(\"4\", (currentClientWidth - inst.paddingL - numX * 2) + numX, currentClientHeight - inst.paddingT - numY * 2 + numY);\r\n            ctx.strokeStyle = \"#000\";\r\n        }\r\n\r\n\r\n        tl(inst.tl_w, inst.tl_h);\r\n        // ml(inst.ml_w, inst.ml_h);\r\n        // bl(inst.bl_w, inst.bl_h);\r\n\r\n\r\n        // tm(inst.tm_w, inst.tm_h);\r\n        // mm(inst.mm_w, inst.mm_h);\r\n        // bm(inst.bm_w, inst.bm_h);\r\n\r\n        rt(inst.rt_w, inst.rt_h);\r\n        // rm(inst.rm_w, inst.rm_h);\r\n        // rb(inst.rb_w, inst.rb_h);\r\n\r\n    }\r\n\r\n    // Greate Red Line\r\n\r\n    let drowRedLine = (inst, dasL, dasR, dasT, dasB) => {\r\n        let drowPlan = document.getElementById(inst.id);\r\n        let ctx = drowPlan.getContext(\"2d\");\r\n\r\n\r\n        let currentClientWidth = drowPlan.clientWidth;\r\n        let currentClientHeight = drowPlan.clientHeight;\r\n\r\n\r\n        let drow = (ctx, inst) => {\r\n            let propX = (currentClientWidth - inst.defaultPaddingL * 2) / inst.widthRoom; // Коэффиценты пропорции \r\n            let propY = (currentClientWidth - inst.paddingT * 2) / inst.heightRoom; // Коэффиценты пропорции \r\n\r\n\r\n            let margin = 50 * propX; //Отступ от стенок в px\r\n\r\n            let leftBX = dasL + margin; // Нижняя левая граница\r\n            let leftBY = currentClientHeight - dasB - margin; // Нижняя левая граница\r\n\r\n            // Точки по которым строится замыкание\r\n            let createRoundGranMas = () => {\r\n                // Ось X\r\n                let XX = [\r\n                    Math.min(currentClientWidth - dasR - margin, currentClientWidth - inst.rm_w * propX - inst.paddingL - margin),\r\n                    currentClientWidth - dasR - margin,\r\n\r\n                    currentClientWidth - dasR - margin,\r\n                    Math.min(currentClientWidth - inst.paddingL - inst.rb_w * propX - margin, currentClientWidth - dasR - margin),\r\n                    Math.min(currentClientWidth - inst.paddingL - inst.rb_w * propX - margin, currentClientWidth - dasR - margin),\r\n                    currentClientWidth * 0.5 + inst.bm_w * propX * 0.5 + margin,\r\n                    currentClientWidth * 0.5 + inst.bm_w * propX * 0.5 + margin,\r\n                    currentClientWidth * 0.5 - inst.bm_w * propX * 0.5 - margin,\r\n                    currentClientWidth * 0.5 - inst.bm_w * propX * 0.5 - margin,\r\n                    Math.max(inst.paddingL + inst.bl_w * propX + margin, dasL + margin), //тут\r\n                    Math.max(inst.paddingL + inst.bl_w * propX + margin, dasL + margin),\r\n                    dasL + margin,\r\n\r\n                    dasL + margin,\r\n                    Math.max(dasL + margin, inst.ml_w * propX + inst.paddingL + margin),\r\n                    Math.max(dasL + margin, inst.ml_w * propX + inst.paddingL + margin),\r\n                    dasL + margin,\r\n\r\n                    dasL + margin,\r\n                    Math.max(inst.paddingL + inst.tl_w * propX + margin, dasL + margin), // и тут\r\n                    Math.max(inst.paddingL + inst.tl_w * propX + margin, dasL + margin),\r\n                    currentClientWidth * 0.5 - inst.tm_w * propX * 0.5 - margin,\r\n                    currentClientWidth * 0.5 - inst.tm_w * propX * 0.5 - margin,\r\n                    currentClientWidth * 0.5 + inst.tm_w * propX * 0.5 + margin,\r\n                    currentClientWidth * 0.5 + inst.tm_w * propX * 0.5 + margin,\r\n                    Math.min(currentClientWidth - inst.paddingL - inst.rt_w * propX - margin, currentClientWidth - dasR - margin),\r\n                    Math.min(currentClientWidth - inst.paddingL - inst.rt_w * propX - margin, currentClientWidth - dasR - margin),\r\n                    currentClientWidth - dasR - margin,\r\n\r\n                    currentClientWidth - dasR - margin,\r\n                    Math.min(currentClientWidth - dasR - margin, currentClientWidth - inst.rm_w * propX - inst.paddingL - margin),\r\n                ]\r\n\r\n                // Ось Y\r\n                let YY = [\r\n                    currentClientHeight * 0.5 + inst.rm_h * propX * 0.5 + margin,\r\n                    currentClientHeight * 0.5 + inst.rm_h * propX * 0.5 + margin,\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.rb_h * propY - margin),\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.rb_h * propY - margin),\r\n                    currentClientHeight - dasB - margin,\r\n                    currentClientHeight - dasB - margin,\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.bm_h * propY - margin),\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.bm_h * propY - margin),\r\n                    currentClientHeight - dasB - margin,\r\n                    currentClientHeight - dasB - margin,\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.bl_h * propY - margin),\r\n                    Math.min(currentClientHeight - dasB - margin, currentClientHeight - inst.paddingT - inst.bl_h * propY - margin),\r\n\r\n                    currentClientHeight * 0.5 + inst.ml_h * propX * 0.5 + margin,\r\n                    currentClientHeight * 0.5 + inst.ml_h * propX * 0.5 + margin,\r\n                    currentClientHeight * 0.5 - inst.ml_h * propX * 0.5 - margin,\r\n                    currentClientHeight * 0.5 - inst.ml_h * propX * 0.5 - margin,\r\n\r\n                    Math.max(dasT + margin, inst.paddingT + inst.tl_h * propY + margin),\r\n                    Math.max(dasT + margin, inst.paddingT + inst.tl_h * propY + margin),\r\n                    dasT + margin,\r\n                    dasT + margin,\r\n                    Math.max(dasT + margin, inst.paddingT + inst.tm_h * propY + margin),\r\n                    Math.max(dasT + margin, inst.paddingT + inst.tm_h * propY + margin),\r\n                    dasT + margin,\r\n                    dasT + margin,\r\n                    Math.max(dasT + margin, inst.paddingT + inst.rt_h * propY + margin),\r\n                    Math.max(dasT + margin, inst.paddingT + inst.rt_h * propY + margin),\r\n\r\n                    currentClientHeight * 0.5 - inst.rm_h * propX * 0.5 - margin,\r\n                    currentClientHeight * 0.5 - inst.rm_h * propX * 0.5 - margin,\r\n                ]\r\n\r\n\r\n                return [\r\n                    { X: XX[0], Y: YY[0] },\r\n                    { X: XX[1], Y: YY[1] },\r\n                    { X: XX[2], Y: YY[2] },\r\n                    { X: XX[3], Y: YY[3] },\r\n                    { X: XX[4], Y: YY[4] },\r\n                    { X: XX[5], Y: YY[5] },\r\n                    { X: XX[6], Y: YY[6] },\r\n                    { X: XX[7], Y: YY[7] },\r\n                    { X: XX[8], Y: YY[8] },\r\n                    { X: XX[9], Y: YY[9] },\r\n                    { X: XX[10], Y: YY[10] },\r\n                    { X: XX[11], Y: YY[11] },\r\n                    { X: XX[12], Y: YY[12] },\r\n                    { X: XX[13], Y: YY[13] },\r\n                    { X: XX[14], Y: YY[14] },\r\n                    { X: XX[15], Y: YY[15] },\r\n                    { X: XX[16], Y: YY[16] },\r\n                    { X: XX[17], Y: YY[17] },\r\n                    { X: XX[18], Y: YY[18] },\r\n                    { X: XX[19], Y: YY[19] },\r\n                    { X: XX[20], Y: YY[20] },\r\n                    { X: XX[21], Y: YY[21] },\r\n                    { X: XX[22], Y: YY[22] },\r\n                    { X: XX[23], Y: YY[23] },\r\n                    { X: XX[24], Y: YY[24] },\r\n                    { X: XX[25], Y: YY[25] },\r\n                    { X: XX[26], Y: YY[26] },\r\n                    { X: XX[27], Y: YY[27] },\r\n                ]\r\n            }\r\n\r\n\r\n            let roundGranMas = createRoundGranMas();\r\n\r\n\r\n            let createZamikanieLine = () => {\r\n                ctx.strokeStyle = \"red\";\r\n\r\n                ctx.beginPath();\r\n\r\n                ctx.moveTo(roundGranMas[0].X, roundGranMas[0].Y);\r\n\r\n                for (let i = 1; i < roundGranMas.length; i++) {\r\n                    ctx.lineTo(roundGranMas[i].X, roundGranMas[i].Y);\r\n                }\r\n\r\n                ctx.lineTo(roundGranMas[0].X, roundGranMas[0].Y);\r\n\r\n                ctx.stroke();\r\n                ctx.strokeStyle = \"black\";\r\n            }\r\n            // createZamikanieLine();\r\n\r\n            let createProkladkaLineVertical = (inst) => {\r\n                let straightLineDirection = inst.straightLineDirection\r\n                let widthTurn = inst.widthTurnReal * propX;\r\n                ctx.strokeStyle = \"green\";\r\n                ctx.beginPath();\r\n\r\n                // Создаем массив только из Х\r\n                let xArray = [];\r\n                for (let i = 0; i < roundGranMas.length; i++) {\r\n                    xArray.push(roundGranMas[i].X);\r\n                }\r\n\r\n\r\n\r\n                // Собираем двумерный массив координат\r\n                let createTwo_dimensional = (two_dimensional = []) => {\r\n                    // Находим наименьший\r\n                    let startX;\r\n                    let endX;\r\n                    if (two_dimensional.length == 0) {\r\n                        startX = Math.max.apply(null, xArray);\r\n                        endX = Math.min.apply(null, xArray);\r\n                    } else {\r\n                        startX = two_dimensional[0][1][0];\r\n                        endX = two_dimensional[two_dimensional.length - 1][1][0];\r\n                        two_dimensional = [];\r\n                    }\r\n                    let two_dimensional_index = 0;\r\n\r\n                    for (let lineX = startX; lineX > endX; lineX -= widthTurn) {\r\n                        let allDots = [];\r\n                        for (let n = 0; n < roundGranMas.length; n++) {\r\n                            if (lineX <= roundGranMas[n].X) {\r\n                                allDots.push(roundGranMas[n].Y);\r\n                            }\r\n                        }\r\n                        // Сортируем этот массив по возрастанию. Соединем две точки подряд\r\n                        allDots.sort((a, b) => { return a - b });\r\n\r\n                        let delItemIndex = [];\r\n                        for (let i = 0; i < allDots.length; i++) {\r\n\r\n                            if (allDots[i] == allDots[i + 1]) {\r\n                                delItemIndex.push(i);\r\n                                i++;\r\n                            }\r\n                        }\r\n                        for (let i = delItemIndex.length - 1; i >= 0; i--) {\r\n\r\n                            allDots.splice(delItemIndex[i], 2);\r\n                        }\r\n\r\n\r\n                        two_dimensional.push([]);\r\n                        for (let i = 0; i < allDots.length; i++) {\r\n                            two_dimensional[two_dimensional_index].push([lineX, allDots[i]]);\r\n                        }\r\n                        two_dimensional_index++;\r\n                    }\r\n\r\n                    return two_dimensional;\r\n\r\n\r\n                };\r\n\r\n\r\n                let two_dimensionalS = createTwo_dimensional();\r\n                // Проверяем на четность витков, увеличиваем ширину витков, если нечёт\r\n                while (two_dimensionalS.length % 2 != 0) {\r\n                    widthTurn += 0.1;\r\n                    two_dimensionalS = createTwo_dimensional()\r\n                }\r\n\r\n                // Считаем длинну системы\r\n                let calcTotalLengthSystem = (two_dimensional) => {\r\n\r\n                    // Считаем длинну вертикальных линий\r\n                    let lenTurn = 0\r\n                    for (let i = 0; i < two_dimensional.length - 1; i++) {\r\n                        lenTurn += (two_dimensional[i][1][1] - two_dimensional[i][0][1]);\r\n                    }\r\n                    // Считаем длинну дуг\r\n                    let lenArc = (two_dimensional.length * 2 * (widthTurn * Math.PI * 0.25));\r\n                    // Считаем длинну прямой линии\r\n                    let startLine = two_dimensional[0][two_dimensional[0].length - 1][0] - widthTurn * 0.5; // Начало прямой линии X\r\n                    let endLine = two_dimensional[two_dimensional.length - 1][two_dimensional[two_dimensional.length - 1].length - 1][0] + widthTurn * 0.5; // Конец прямой линии X\r\n                    let lenStraightLine = (startLine - endLine);\r\n\r\n                    let lenTotal = (lenTurn + lenArc + lenStraightLine) / propX;\r\n                    return lenTotal;\r\n                }\r\n\r\n                let sliceTwo_demensional = (two_dimensional) => {\r\n                    let two_dimensional_B = [];\r\n                    while (calcTotalLengthSystem(two_dimensional) > 85000) { // Максимальная длинна 84м + 1м погрешность\r\n                        two_dimensional_B = (two_dimensional.splice(two_dimensional.length - 2, 2)).concat(two_dimensional_B);\r\n                    }\r\n                    return two_dimensional_B;\r\n                }\r\n\r\n\r\n                // Отрисовка\r\n                let drowVerticalLines = (two_dimensional, countColor = 1) => {\r\n\r\n                    // if (countColor % 4 != 0) {\r\n                    //     ctx.strokeStyle = \"green\";\r\n                    //     console.log(`Цвет1: ${ctx.strokeStyle}`)\r\n                    // } else {\r\n                    //     ctx.strokeStyle = \"darkorchid\";\r\n                    //     console.log(`Цвет2: ${ctx.strokeStyle}`)\r\n                    // }\r\n\r\n                    // Если линия снизу\r\n                    let hFromBottomLine = 0;\r\n                    let hFromTopLine = 0;\r\n                    if (straightLineDirection) {\r\n                        hFromBottomLine = widthTurn;\r\n                    } else {\r\n                        hFromTopLine = widthTurn;\r\n                    }\r\n\r\n                    let count = 0; // Счетчик чёт нечёт\r\n                    // Отрисовываем витки по массиву\r\n                    for (let n = 0; n < two_dimensional.length; n++) {\r\n                        for (let i = 0; i < two_dimensional[n].length; i += 2) {\r\n\r\n                            if (count % 2 == 0) { //Четная линия, с неё всегда начинается\r\n                                // не рисуем верхний участок отделенный от основной линии\r\n                                if (two_dimensional[n].length != 2 && i < 2) {\r\n                                    continue\r\n                                }\r\n                                // Выравнивание по высоте верхнюю часть\r\n\r\n                                if (n < two_dimensional.length - 1) {\r\n                                    if (two_dimensional[n][0][1] < two_dimensional[n + 1][0][1]) {\r\n                                        two_dimensional[n][0][1] = two_dimensional[n + 1][0][1];\r\n                                    }\r\n                                }\r\n\r\n                                // Выравнивание по высоте нижнюю часть\r\n                                if (n != 0) {\r\n                                    let currentLast = two_dimensional[n].length - 1;\r\n                                    let prevLast = two_dimensional[n - 1].length - 1;\r\n                                    if (two_dimensional[n][currentLast][1] > two_dimensional[n - 1][prevLast][1]) {\r\n                                        two_dimensional[n][currentLast][1] = two_dimensional[n - 1][prevLast][1];\r\n                                    }\r\n                                }\r\n\r\n\r\n\r\n                                ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine);\r\n                                if (n == 0) { //У первого элемента высоту не меняем\r\n                                    ctx.lineTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5);\r\n                                } else {\r\n                                    ctx.lineTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine);\r\n                                }\r\n\r\n\r\n\r\n                                // дуги\r\n                                ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine);\r\n                                ctx.arc(two_dimensional[n][i][0] - widthTurn * 0.5, two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine, widthTurn * 0.5, 0, Math.PI * (3 / 2), true);\r\n\r\n                                // Если прямая снизу то дугу у первого элемента не рисуем\r\n                                if (count == 0 || count == (two_dimensional.length - 1)) {\r\n\r\n                                } else {\r\n                                    ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine);\r\n                                    ctx.arc(two_dimensional[n][i][0] + widthTurn * 0.5, two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine, widthTurn * 0.5, Math.PI, Math.PI * 0.5, true);\r\n                                }\r\n\r\n                            } else { // Нечётная линия\r\n                                // не рисуем верхний участок отделенный от основной линии\r\n                                if (two_dimensional[n].length != 2 && i < 2) {\r\n                                    continue\r\n                                }\r\n                                // Выравнивание по высоте верхнюю часть\r\n                                if (two_dimensional[n][0][1] < two_dimensional[n - 1][0][1]) {\r\n                                    two_dimensional[n][0][1] = two_dimensional[n - 1][0][1];\r\n                                }\r\n                                // Выравнивание по высоте нижнюю часть\r\n                                if (n < two_dimensional.length - 2) {\r\n                                    let currentLast = two_dimensional[n].length - 1;\r\n                                    let nextLast = two_dimensional[n + 1].length - 1;\r\n                                    if (two_dimensional[n][currentLast][1] > two_dimensional[n + 1][nextLast][1]) {\r\n                                        two_dimensional[n][currentLast][1] = two_dimensional[n + 1][nextLast][1];\r\n                                    }\r\n                                }\r\n\r\n                                ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine);\r\n                                if (n == two_dimensional.length - 1) { //У последнего элемента высоту не меняем\r\n                                    ctx.lineTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5);\r\n                                } else {\r\n                                    ctx.lineTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine);\r\n                                }\r\n\r\n                                // дуги\r\n                                ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine);\r\n                                ctx.arc(two_dimensional[n][i][0] + widthTurn * 0.5, two_dimensional[n][i][1] + widthTurn * 0.5 + hFromTopLine, widthTurn * 0.5, Math.PI, Math.PI * (3 / 2), false);\r\n                                // Если прямая снизу то дугу у последнего элемента не рисуем\r\n                                if (count == 0 || count == (two_dimensional.length - 1)) {\r\n\r\n                                } else {\r\n                                    ctx.moveTo(two_dimensional[n][i][0], two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine);\r\n                                    ctx.arc(two_dimensional[n][i][0] - widthTurn * 0.5, two_dimensional[n][i + 1][1] - widthTurn * 0.5 - hFromBottomLine, widthTurn * 0.5, 0, Math.PI * 0.5, false);\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n                        count++\r\n                    }\r\n\r\n                    // Рисуем прямую\r\n                    let straighttLineBottom = () => {\r\n                        let startLine = two_dimensional[0][two_dimensional[0].length - 1][0] - widthTurn * 0.5; // Начало прямой линии X\r\n                        let endLine = two_dimensional[two_dimensional.length - 1][two_dimensional[two_dimensional.length - 1].length - 1][0] + widthTurn * 0.5; // Конец прямой линии X\r\n                        // Находим Y\r\n                        let yLine = two_dimensional[0][two_dimensional[0].length - 1][1];\r\n                        for (let i = 1; i < two_dimensional.length; i++) {\r\n                            if (two_dimensional[i][two_dimensional[i].length - 1][1] < two_dimensional[i - 1][two_dimensional[i - 1].length - 1][1]) {\r\n                                yLine = two_dimensional[i][two_dimensional[i].length - 1][1];\r\n                            }\r\n                        }\r\n\r\n                        ctx.moveTo(startLine, yLine);\r\n                        ctx.lineTo(endLine, yLine);\r\n\r\n                        ctx.moveTo(startLine + widthTurn * 0.5, yLine - widthTurn * 0.5);\r\n                        ctx.arc(startLine, yLine - widthTurn * 0.5, widthTurn * 0.5, 0, Math.PI * (1 / 2), false);\r\n\r\n                        ctx.moveTo(endLine, yLine);\r\n                        ctx.arc(endLine, yLine - widthTurn * 0.5, widthTurn * 0.5, Math.PI * (1 / 2), Math.PI, false);\r\n                    }\r\n                    straighttLineBottom();\r\n                };\r\n\r\n                //Коректируем ширину витков, чтоб подогнать под нужную длинну системы\r\n                let correctWidthTurn = (two_dimensional) => {\r\n                    let lengthList = [7000, 14000, 21000, 28000, 35000, 42000, 56000, 70000, 84000];\r\n                    let systemLength = calcTotalLengthSystem(two_dimensional);\r\n                    let nearLength;\r\n                    let lenghtDelta = 15000;\r\n                    for (let i = 0; i < lengthList.length; i++) {\r\n                        if (lenghtDelta > Math.abs(systemLength - lengthList[i])) {\r\n\r\n                            lenghtDelta = systemLength - lengthList[i];\r\n                            nearLength = lengthList[i];\r\n                        }\r\n                    }\r\n                    return nearLength;\r\n                }\r\n\r\n                // Создаем массив из всех систем для отрисовки каждой\r\n                let createAll_demensional = (two_dimensional) => {\r\n                    let all_two_dem = [];\r\n                    let two_dem_done = two_dimensional;\r\n\r\n                    while (true) {\r\n\r\n                        let two_dem = sliceTwo_demensional(two_dem_done);\r\n\r\n                        if (two_dem.length == 0) {\r\n                            all_two_dem.push(two_dem_done);\r\n\r\n                            break;\r\n                        }\r\n                        all_two_dem.push(two_dem_done);\r\n\r\n                        two_dem_done = two_dem;\r\n                    }\r\n                    return all_two_dem;\r\n                }\r\n\r\n                let two_dimensionalAll = createAll_demensional(two_dimensionalS);\r\n\r\n\r\n                let two_dimensionalAll_last = two_dimensionalAll[two_dimensionalAll.length - 1];\r\n                // while (Math.abs(calcTotalLengthSystem(two_dimensionalAll_last) - correctWidthTurn(two_dimensionalAll_last)) > 1000) {\r\n                //     let dsfdfg = calcTotalLengthSystem(two_dimensionalAll_last);\r\n                //     let dfgdfgdfg = correctWidthTurn(two_dimensionalAll_last);\r\n                //     widthTurn += 0.1;\r\n                //     two_dimensionalAll_last = createTwo_dimensional(two_dimensionalAll_last);\r\n                // }\r\n                // widthTurn = inst.widthTurnReal * propX;\r\n\r\n                // while (two_dimensionalAll_last.length % 2 != 0) {\r\n                //     widthTurn += 0.1;\r\n                //     two_dimensionalAll_last = createTwo_dimensional(two_dimensionalAll_last)\r\n                // }\r\n                two_dimensionalAll[two_dimensionalAll.length - 1] = two_dimensionalAll_last;\r\n\r\n                let infoText = \"\";\r\n\r\n                infoText += `Количество систем: ${two_dimensionalAll.length} шт. \\n`;\r\n\r\n                for (let p = 0; p < two_dimensionalAll.length; p++) {\r\n                    let countColor = p;\r\n                    drowVerticalLines(two_dimensionalAll[p], countColor);\r\n                    // ${calcTotalLengthSystem(two_dimensionalAll[p])}мм\r\n                    infoText += `Система ${p + 1}: длина системы: ${correctWidthTurn(two_dimensionalAll[p])}мм, шаг укладки: ${Math.round(widthTurn / propX)}мм. \\n`;\r\n                }\r\n\r\n                if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".calculator__room__bottom\")) {\r\n\r\n                    if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".infoBlockSpan\")) {\r\n                        document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".infoBlockSpan\").remove();\r\n                    }\r\n\r\n                    let infoBlockSpan = document.createElement('div');\r\n\r\n                    infoBlockSpan.classList.add(\"infoBlockSpan\");\r\n                    infoBlockSpan.id = `description-${inst.id.slice(-1) - 2}`;\r\n                    infoBlockSpan.style.whiteSpace = \"break-spaces\";\r\n                    infoBlockSpan.innerHTML = `<span>${infoText}</span>`;\r\n                    document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".calculator__room__bottom\").prepend(infoBlockSpan);\r\n                }\r\n\r\n\r\n                if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelectorAll(\".infoBlockSpan\").length > 1) {\r\n                    let delItems = document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelectorAll(\".infoBlockSpan\");\r\n                    for (let i = 0; i < delItems.length - 1; i++) {\r\n                        delItems[i].remove();\r\n                    }\r\n                }\r\n\r\n                ctx.stroke();\r\n                ctx.strokeStyle = \"black\";\r\n\r\n\r\n            }\r\n\r\n\r\n\r\n            let createProkladkaLineHorizon = () => {\r\n                ctx.strokeStyle = \"green\";\r\n                ctx.beginPath();\r\n\r\n                // Создаем массив только из Y\r\n                let xArray = [];\r\n                for (let i = 0; i < roundGranMas.length; i++) {\r\n                    xArray.push(roundGranMas[i].Y);\r\n                }\r\n                // Находим наименьший\r\n                let startY = Math.max.apply(null, xArray);\r\n                let endY = Math.min.apply(null, xArray);\r\n\r\n\r\n                for (lineY = startY; lineY > endY; lineY -= 40) {\r\n                    let allDots = [];\r\n                    for (let n = 0; n < roundGranMas.length; n++) {\r\n                        if (lineY <= roundGranMas[n].Y) {\r\n                            // Создаем массив всех точек удовлетворяющих условию\r\n                            allDots.push(roundGranMas[n].X);\r\n                        }\r\n                    }\r\n                    // Сортируем этот массив по возрастанию. Соединем две точки подряд\r\n                    allDots.sort((a, b) => { return a - b });\r\n\r\n                    for (let i = 0; i < allDots.length; i += 2) {\r\n                        ctx.moveTo(allDots[i], lineY);\r\n                        ctx.lineTo(allDots[i + 1], lineY);\r\n                    }\r\n                }\r\n\r\n                ctx.stroke();\r\n                ctx.strokeStyle = \"black\";\r\n            }\r\n\r\n            createProkladkaLineVertical(inst);\r\n            // createProkladkaLineHorizon();\r\n\r\n\r\n        }\r\n        drow(ctx, inst);\r\n\r\n        let myMockContext = new C2S(500, 500);\r\n        drow(myMockContext, inst);\r\n        goSVG.push(myMockContext.getSerializedSvg());\r\n\r\n        let createGreatSVG = (goSVG) => {\r\n            `<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"500\" height=\"500\"><defs></defs>`;\r\n            for (let u = 0; u < goSVG.length; u++) {\r\n                let start = goSVG[u].indexOf(\"<g>\");\r\n                let end = goSVG[u].indexOf(\"</g>\");\r\n                goSVG[u] = goSVG[u].slice(start, end);\r\n            };\r\n            let allPart = \"\";\r\n            for (let u = 0; u < goSVG.length; u++) {\r\n                allPart += goSVG[u];\r\n            }\r\n            let GreatSVG = `<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"500\" height=\"500\"><defs></defs>` + allPart + \"</svg>\";\r\n            return GreatSVG;\r\n        }\r\n\r\n        if (document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".calculator__room__bottom__svg\").innerHTML.length < 100) {\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".calculator__room__bottom__svg\").innerHTML = \"\";\r\n\r\n            document.querySelectorAll(\"[fid]\")[inst.id.slice(-1) - 2].querySelector(\".calculator__room__bottom__svg\").innerHTML = createGreatSVG(goSVG);\r\n\r\n        }\r\n        goSVG = [];\r\n\r\n    }\r\n\r\n\r\n    let canvasIdAll = Object(_searchAllCanvasBlock__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); //!!! Находим все canvas элементы\r\n\r\n\r\n    //Выбираем все блоки с канвас и начинаем отрисовку\r\n    for (let x = 0; x < canvasIdAll.length; x++) {\r\n        canvasStartDrow(new _createInst__WEBPACK_IMPORTED_MODULE_1__[\"default\"](canvasIdAll[x]));\r\n    }\r\n\r\n    // Кнопки добвления комнат\r\n    let addRoomBtns = document.querySelectorAll(\".calculator__add_room\");\r\n    addRoomBtns.forEach((elem) => {\r\n        elem.addEventListener(\"click\", function () {\r\n            setTimeout(myInitCode, 1000)\r\n        });\r\n    })\r\n\r\n    // Кнопки добавления этажей\r\n    let addFloorBtns = document.querySelectorAll(\".calculator__add_floor\");\r\n    addFloorBtns.forEach((elem) => {\r\n        elem.addEventListener(\"click\", function () {\r\n            setTimeout(myInitCode, 1000)\r\n        });\r\n    })\r\n\r\n\r\n    //events\r\n    let drowPlan_level2_wrapper = document.querySelector(\".drowPlan-level2-wrapper\");\r\n    dispatchForm(\"drowPlan\", \"drowPlanlLevel2\");\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (myInitCode);\n\n//# sourceURL=webpack:///./app/drowCalc_init.js?");

/***/ }),

/***/ "./app/drowDashLinemainBorder.js":
/*!***************************************!*\
  !*** ./app/drowDashLinemainBorder.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n // Отступ от стен\r\n\r\n let drowDashLinemainBorder = (id, pleft, ptop, pright, pbottom, currentClientWidth, currentClientHeight) => {\r\n    let drowPlan = document.getElementById(id);\r\n    let ctx = drowPlan.getContext(\"2d\");\r\n\r\n    let drow = (ctx, clientWidth, clientHeight, pleft, ptop, pright, pbottom) => {\r\n        ctx.setLineDash([4, 6]);\r\n        ctx.beginPath();\r\n\r\n\r\n        ctx.moveTo(pleft, ptop);\r\n        ctx.lineTo(pleft, clientHeight - pbottom);\r\n        ctx.lineTo(clientWidth - pright, clientHeight - pbottom);\r\n        ctx.lineTo(clientWidth - pright, ptop);\r\n        ctx.lineTo(pleft, ptop);\r\n        ctx.stroke();\r\n\r\n        ctx.setLineDash([]);\r\n    }\r\n\r\n    let myMockContext = new C2S(500, 500);\r\n    drow(myMockContext, currentClientWidth, currentClientHeight, pleft, ptop, pright, pbottom);\r\n    // goSVG.push(myMockContext.getSerializedSvg());\r\n\r\n    drow(ctx, currentClientWidth, currentClientHeight, pleft, ptop, pright, pbottom);\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (drowDashLinemainBorder);\n\n//# sourceURL=webpack:///./app/drowDashLinemainBorder.js?");

/***/ }),

/***/ "./app/searchAllCanvasBlock.js":
/*!*************************************!*\
  !*** ./app/searchAllCanvasBlock.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nlet searchAllCanvasBlock = () => {\r\n    let allCanvas = document.querySelectorAll(\"[fid] canvas\");\r\n    let canvasIdAll = [];\r\n\r\n    if (allCanvas.length > 0) {\r\n        for (let i = 0; i < allCanvas.length; i++) {\r\n            allCanvas[i].id = `drowPlanlLevel${i + 2}`;\r\n            canvasIdAll.push(`drowPlanlLevel${i + 2}`);\r\n        }\r\n    }\r\n\r\n    return canvasIdAll;\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (searchAllCanvasBlock);\n\n//# sourceURL=webpack:///./app/searchAllCanvasBlock.js?");

/***/ }),

/***/ "./app/sizeLines.js":
/*!**************************!*\
  !*** ./app/sizeLines.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//Разметка размеров w и h\r\nlet sizeLines = (inst) => {\r\n    let drowPlan = document.getElementById(inst.id);\r\n    let ctx = drowPlan.getContext(\"2d\");\r\n\r\n    let currentClientWidth = drowPlan.clientWidth;\r\n    let currentClientHeight = drowPlan.clientHeight;\r\n\r\n    let drowTop = (ctx, inst) => {\r\n        ctx.strokeStyle = \"red\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(inst.paddingL, inst.paddingT);\r\n        ctx.lineTo(inst.paddingL, inst.paddingT - 40);\r\n        ctx.moveTo(inst.paddingL, inst.paddingT - 25);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL, inst.paddingT - 25);\r\n        ctx.moveTo(currentClientWidth - inst.paddingL, inst.paddingT - 40);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL, inst.paddingT);\r\n        ctx.stroke();\r\n\r\n        // Буква в центре\r\n        ctx.font = 'bold 30px sans-serif';\r\n        ctx.textBaseline = \"bottom\";\r\n        ctx.strokeStyle = \"#F00\";\r\n        ctx.textBaseline = \"bottom\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(\"B\", currentClientWidth / 2, inst.paddingT - 25);\r\n        ctx.strokeStyle = \"#000\";\r\n\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n\r\n    let drowLeft = (ctx, inst) => {\r\n        ctx.strokeStyle = \"red\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(inst.paddingL, currentClientHeight - inst.paddingT);\r\n        ctx.lineTo(inst.paddingL - 40, currentClientHeight - inst.paddingT);\r\n        ctx.moveTo(inst.paddingL - 25, currentClientHeight - inst.paddingT);\r\n        ctx.lineTo(inst.paddingL - 25, inst.paddingT);\r\n        ctx.moveTo(inst.paddingL - 40, inst.paddingT);\r\n        ctx.lineTo(inst.paddingL, inst.paddingT);\r\n        ctx.stroke();\r\n\r\n        // Буква в центре\r\n        ctx.font = 'bold 30px sans-serif';\r\n        ctx.strokeStyle = \"#F00\";\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(\"A\", inst.paddingL - 40, currentClientHeight / 2);\r\n        ctx.strokeStyle = \"#000\";\r\n\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n\r\n    let drowRight = (ctx, inst) => {\r\n        ctx.strokeStyle = \"red\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(currentClientWidth - inst.paddingL, currentClientHeight - inst.paddingT);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL + 40, currentClientHeight - inst.paddingT);\r\n        ctx.moveTo(currentClientWidth - inst.paddingL + 25, currentClientHeight - inst.paddingT);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL + 25, inst.paddingT);\r\n        ctx.moveTo(currentClientWidth - inst.paddingL + 40, inst.paddingT);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL, inst.paddingT);\r\n        ctx.stroke();\r\n\r\n        // Буква в центре\r\n        ctx.font = 'bold 30px sans-serif';\r\n        ctx.strokeStyle = \"#F00\";\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(\"C\", currentClientWidth - inst.paddingL + 40, currentClientHeight / 2);\r\n        ctx.strokeStyle = \"#000\";\r\n\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n\r\n    let drowBottom = (ctx, inst) => {\r\n        ctx.strokeStyle = \"red\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(inst.paddingL, currentClientHeight - inst.paddingT);\r\n        ctx.lineTo(inst.paddingL, currentClientHeight - inst.paddingT + 40);\r\n        ctx.moveTo(inst.paddingL, currentClientHeight - inst.paddingT + 25);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL, currentClientHeight - inst.paddingT + 25);\r\n        ctx.moveTo(currentClientWidth - inst.paddingL, currentClientHeight - inst.paddingT + 40);\r\n        ctx.lineTo(currentClientWidth - inst.paddingL, currentClientHeight - inst.paddingT);\r\n        ctx.stroke();\r\n\r\n        // Буква в центре\r\n        ctx.font = 'bold 30px sans-serif';\r\n        ctx.strokeStyle = \"#F00\";\r\n        ctx.textBaseline = \"top\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.strokeText(\"D\", currentClientWidth / 2, currentClientHeight - inst.paddingT + 28);\r\n        ctx.strokeStyle = \"#000\";\r\n\r\n        ctx.strokeStyle = \"black\";\r\n    }\r\n\r\n    let myMockContext1 = new C2S(500, 500);\r\n    let myMockContext2 = new C2S(500, 500);\r\n    let myMockContext3 = new C2S(500, 500);\r\n    let myMockContext4 = new C2S(500, 500);\r\n    drowTop(myMockContext1, inst);\r\n    drowLeft(myMockContext2, inst);\r\n    drowRight(myMockContext3, inst);\r\n    drowBottom(myMockContext4, inst)\r\n    goSVG.push(myMockContext1.getSerializedSvg());\r\n    goSVG.push(myMockContext2.getSerializedSvg());\r\n    goSVG.push(myMockContext3.getSerializedSvg());\r\n    goSVG.push(myMockContext4.getSerializedSvg());\r\n\r\n    drowTop(ctx, inst);\r\n    drowLeft(ctx, inst);\r\n    drowRight(ctx, inst);\r\n    drowBottom(ctx, inst)\r\n}\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (sizeLines);\n\n//# sourceURL=webpack:///./app/sizeLines.js?");

/***/ }),

/***/ "./drowCalc_dev.js":
/*!*************************!*\
  !*** ./drowCalc_dev.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_drowCalc_init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app/drowCalc_init.js */ \"./app/drowCalc_init.js\");\n\r\n\r\n\r\n\r\nif (document.readyState !== 'loading') {\r\n    Object(_app_drowCalc_init_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n\r\n} else {\r\n    document.addEventListener('DOMContentLoaded', function() {\r\n        Object(_app_drowCalc_init_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\r\n    });\r\n}\n\n//# sourceURL=webpack:///./drowCalc_dev.js?");

/***/ })

/******/ });